/**
 * Database Connection
 * Auto-generated by Module Library Assembler
 *
 * Uses PostgreSQL when DATABASE_URL is set (production)
 * Falls back to local SQLite for test mode (no DATABASE_URL)
 */

// Check if we have a PostgreSQL connection string
if (process.env.DATABASE_URL) {
  // Production mode - use PostgreSQL
  const { Pool } = require('pg');

  const pool = new Pool({
    connectionString: process.env.DATABASE_URL,
    ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
  });

  // Test connection on startup
  pool.query('SELECT NOW()')
    .then(() => console.log('âœ… PostgreSQL database connected'))
    .catch((err) => {
      console.log('âš ï¸  PostgreSQL connection failed:', err.message);
    });

  module.exports = {
    query: (text, params) => pool.query(text, params),
    pool
  };
} else {
  // Test mode - use local SQLite database
  console.log('ðŸ§ª Test Mode: Using local SQLite database');

  const Database = require('better-sqlite3');
  const path = require('path');
  const bcrypt = require('bcryptjs');

  // Create database file in backend folder
  const dbPath = path.join(__dirname, 'test-data.db');
  const db = new Database(dbPath);

  // Enable foreign keys
  db.pragma('foreign_keys = ON');

  /**
   * Convert PostgreSQL parameterized query to SQLite
   * PostgreSQL: SELECT * FROM users WHERE id = $1 AND email = $2
   * SQLite:     SELECT * FROM users WHERE id = ? AND email = ?
   */
  function convertQuery(text) {
    return text.replace(/\$\d+/g, '?');
  }

  /**
   * Execute query with PostgreSQL-compatible interface
   */
  function query(text, params = []) {
    const sqliteQuery = convertQuery(text);
    const isSelect = sqliteQuery.trim().toUpperCase().startsWith('SELECT');
    const isInsertReturning = sqliteQuery.toUpperCase().includes('RETURNING');

    try {
      if (isSelect) {
        const stmt = db.prepare(sqliteQuery);
        const rows = stmt.all(...params);
        return Promise.resolve({ rows, rowCount: rows.length });
      } else if (isInsertReturning) {
        const baseQuery = sqliteQuery.replace(/\s+RETURNING\s+.*/i, '');
        const stmt = db.prepare(baseQuery);
        const result = stmt.run(...params);
        return Promise.resolve({
          rows: [{ id: result.lastInsertRowid }],
          rowCount: result.changes
        });
      } else {
        const stmt = db.prepare(sqliteQuery);
        const result = stmt.run(...params);
        return Promise.resolve({ rows: [], rowCount: result.changes });
      }
    } catch (error) {
      console.error('SQLite query error:', error.message);
      return Promise.reject(error);
    }
  }

  // Initialize schema
  db.exec(`
    CREATE TABLE IF NOT EXISTS users (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      email TEXT UNIQUE NOT NULL,
      password_hash TEXT NOT NULL,
      full_name TEXT,
      subscription_tier TEXT DEFAULT 'free',
      is_admin INTEGER DEFAULT 0,
      scans_used INTEGER DEFAULT 0,
      reset_token TEXT,
      reset_token_expires TEXT,
      created_at TEXT DEFAULT CURRENT_TIMESTAMP
    )
  `);

  db.exec(`
    CREATE TABLE IF NOT EXISTS orders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      user_id INTEGER,
      items TEXT NOT NULL,
      total REAL NOT NULL,
      status TEXT DEFAULT 'pending',
      source TEXT DEFAULT 'website',
      payment_type TEXT DEFAULT 'cash',
      customer_name TEXT DEFAULT 'Guest',
      customer_email TEXT,
      customer_phone TEXT,
      notes TEXT,
      created_at TEXT DEFAULT CURRENT_TIMESTAMP,
      updated_at TEXT
    )
  `);

  db.exec(`
    CREATE TABLE IF NOT EXISTS menu_categories (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      description TEXT,
      sort_order INTEGER DEFAULT 0,
      created_at TEXT DEFAULT CURRENT_TIMESTAMP
    )
  `);

  db.exec(`
    CREATE TABLE IF NOT EXISTS menu_items (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      category_id INTEGER,
      name TEXT NOT NULL,
      description TEXT,
      price REAL NOT NULL,
      image_url TEXT,
      is_available INTEGER DEFAULT 1,
      is_popular INTEGER DEFAULT 0,
      sort_order INTEGER DEFAULT 0,
      created_at TEXT DEFAULT CURRENT_TIMESTAMP
    )
  `);

  // Seed default users if not exists
  const adminCheck = db.prepare('SELECT id FROM users WHERE email = ?').get('admin@test.com');
  if (!adminCheck) {
    const adminHash = bcrypt.hashSync('admin123', 12);
    db.prepare('INSERT INTO users (email, password_hash, full_name, is_admin) VALUES (?, ?, ?, ?)').run('admin@test.com', adminHash, 'Test Admin', 1);
    console.log('   Created admin user: admin@test.com / admin123');
  }

  const demoCheck = db.prepare('SELECT id FROM users WHERE email = ?').get('demo@test.com');
  if (!demoCheck) {
    const demoHash = bcrypt.hashSync('demo123', 12);
    db.prepare('INSERT INTO users (email, password_hash, full_name, is_admin) VALUES (?, ?, ?, ?)').run('demo@test.com', demoHash, 'Demo User', 0);
    console.log('   Created demo user: demo@test.com / demo123');
  }

  console.log('âœ… SQLite database ready:', dbPath);

  module.exports = {
    query,
    db,
    pool: null
  };
}
